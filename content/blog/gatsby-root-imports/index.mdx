---
title: Add absolute file imports to your Gatsby project
date: '2022-06-06'
featured_image: ./images/featured.jpg
featured_image_alt: A tree with tangled branches.
featured_image_credit: Faye Cornish
featured_image_link: https://unsplash.com/photos/ywRNdDfvMWs
excerpt: Simplify your Gatsby development by converting your relative imports to absolute imports.
topics: ['gatsby', 'react', 'productivity']
---

Have you ever written code like this?

```javascript
import { CustomButton } from '../../../components/buttons/custom-button';
import { customHook } from '../../../hooks/custom-hook';
```

When you're working with any kind of non-trivial codebase, it's easy to end up with multiple embedded layers of folders, and that can turn your file imports into a tangled web of dots and slashes.

This tutorial will show you how you can update your Gatsby project to convert your old relative file imports into absolute, aliased imports, like this:

```javascript
import { CustomButton } from '@/components';
import { customHook } from '@/hooks';
```

<CodeNote href="https://github.com/rutterjt/blog-examples/tree/main/gatsby-root-imports" />

## Configuring root imports

The first step to prettifying our file imports will be configuring our Gatsby project to support root imports, such as:

```javascript
import { TestComponent } from 'src/components/test-component';
```

There's a few things we'll need to do to achieve this:

1. Configure webpack to understand absolute imports.
2. Configure other technologies that need to know about how to correctly import files (e.g., TypeScript or Jest).

### Configuring Webpack to support root imports

Configuring webpack can be complex, but fortunately there's a Gatsby plugin that'll take care of that for us: [gatsby-plugin-root-import](https://www.gatsbyjs.com/plugins/gatsby-plugin-root-import/). Let's install it:

```bash
npm install gatsby-plugin-root-import
```

Next, we'll need to add the plugin to our gatsby-config:

<CodeTabs one="JavaScript" two="TypeScript">
  <CodePanel>

```javascript
const config = {
  // ...
  plugins: [`gatsby-plugin-root-import`],
};
export default config;
```

  </CodePanel>
  <CodePanel>

```typescript
import type { GatsbyConfig } from 'gatsby';

const config: GatsbyConfig = {
  // ...
  plugins: [`gatsby-plugin-root-import`],
};
export default config;
```

  </CodePanel>
</CodeTabs>

We'll add some additional configuration later, but by default the plugin supports directly importing files relative to the project's root. So now we can directly import files from the `src` folder, like:

```javascript
import { CustomButton } from 'src/components/buttons/custom-button';
```

Already that's an improvement over the old relative imports!

<Note color="blue">

_**Note**: if you'd like to try configuring webpack yourself, you can do that through gatsby-node's `onCreateWebpackConfig` api. For more information, check out this [how-to guide on configuring webpack](https://www.gatsbyjs.com/docs/how-to/custom-configuration/add-custom-webpack-config/) from the Gatsby docs._

</Note>

### Adding TypeScript support for root imports

If your project uses TypeScript, you'll need to add another step so that the TypeScript compiler can understand the absolute imports.

In your `tsconfig.json` file, add the following:

```json
{
  "compilerOptions": {
    // ...
    "baseUrl": "."
  }
}
```

This lets TypeScript know that whatever you set as the `baseUrl` (in this case, the project root) should be treated as the base directory when resolving non-relative file imports. So in our example, when TypeScript encounters `src/components`, it'll treat that as `./src/components` (relative to the project root).

## Adding import aliases

Your project should now support absolute file paths in imports. Great! But there are a few more tweaks we can do to make our imports even simpler.

First, we can use import aliases.

As it stands now, your project should now support importing components like:

```javascript
import { CustomButton } from 'src/components/buttons/custom-button';
```

Let's add an import alias to turn that into:

```javascript
import { CustomButton } from '@/components/buttons/custom-button';
```

Although that doesn't look like a big difference now, it's a starting point to make our imports much shorter.

### Update webpack config to support aliases

Again, we'll need to let webpack know of our changes. Fortunately, `gatsby-plugin-root-import` can do the heavy lifting for us again. Update your gatsby-config like so:

<CodeTabs one="JavaScript" two="TypeScript">
  <CodePanel>

```javascript
import path from 'path';
const config = {
  // ...
  plugins: [
    // ...
    {
      resolve: 'gatsby-plugin-root-import',
      options: {
        '@': path.join(__dirname, 'src'),
      },
    },
  ],
};
export default config;
```

  </CodePanel>
  <CodePanel>

```typescript
import type { GatsbyConfig } from 'gatsby';
import path from 'path';

const config: GatsbyConfig = {
  // ...
  plugins: [
    // ...
    {
      resolve: 'gatsby-plugin-root-import',
      options: {
        '@': path.join(__dirname, 'src'),
      },
    },
  ],
};
export default config;
```

  </CodePanel>
</CodeTabs>

Each entry added to `options` will be treated by the plugin as a webpack import alias. So in other words, we've just told webpack to convert `@` to `src`.

You can add as many import aliases as you like. For example, you could add a separate alias for `@components` or `@hooks`.

This is especially useful if you're using deeply nested folders. For example, Redux recommends [organizing your logic into "feature folders"](https://redux.js.org/faq/code-structure#what-should-my-file-structure-look-like-how-should-i-group-my-action-creators-and-reducers-in-my-project-where-should-my-selectors-go), like `./src/features/todos`. If you structure your program like this, you may find it convenient to alias `./src/features/todos` as simply `@todos`.

### Update TypeScript to support aliases

Now that we've added an import alias to our config, we'll need to update TypeScript to understand how to compile the new imports. In our `tsconfig.json` file:

```json
{
  "compilerOptions": {
    // ...
    "paths": {
      "@/*": ["src/*"]
    }
  }
}
```

Any entries added to [`paths`](https://www.typescriptlang.org/tsconfig#paths) be re-mapped by TypeScript. Note that all mappings are relative to whatever was specified in the `baseUrl`. If you're interested, you can read more about [tsconfig paths](https://www.typescriptlang.org/tsconfig#paths) in the TypeScript docs.

<Note color="blue">

_**Note**: If you're using VS Code, you may need to restart it before the new import aliases are recognized._

</Note>

### Support aliases in Jest

If you're using Jest to test your Gatsby project, you'll need to update your Jest config to support import aliases. First, make sure you've correctly configured Jest to work with Gatsby. For more information on that, check out this tutorial from the Gatsby docs on [adding unit tests to Gatsby](https://www.gatsbyjs.com/docs/how-to/testing/unit-testing/).

You can configure Jest to understand path aliases by adding them to `moduleNameMapper` in your `jest.config.js`. If your project uses TypeScript, you can easily import the path aliases from `tsconfig.json` using a utility function from [ts-jest](https://github.com/kulshekhar/ts-jest):

```javascript
const { compilerOptions } = require('./tsconfig.json');
const { pathsToModuleNameMapper } = require('ts-jest');

const paths = pathsToModuleNameMapper(compilerOptions.paths, {
  prefix: '<rootDir>/',
});

module.exports = {
  // ...

  moduleNameMapper: {
    // ... other module names
    ...paths,
  },

  // ...
};
```

Using `pathsToModuleNameMapper`, Jest will always be in sync with your `tsconfig.json` import aliases, and any time you update your import aliases in `tsconfig.json`, the changes will be automatically recognized by Jest. Otherwise, you'll need to manually specify all of the path aliases in `jest.config.js`:

```javascript
module.exports = {
  // ...

  moduleNameMapper: {
    // ... other module names
    '^@/(.*)': '<rootDir>/src/$1', // configuring the @ alias
  },

  // ...
};
```

<Note color="blue">

_See the Jest docs for [more information about mapping module names](https://jestjs.io/docs/configuration#modulenamemapper-objectstring-string--arraystring)._

</Note>

## Re-export components

A final step that I like to do in some of my projects is to re-export components from the base `./components` directory.

For example, consider a project structured like this:

```
src
└── components
    ├── test-component-one.tsx
    ├── test-component-two.tsx
    └── buttons
        └── custom-button.tsx
```

In the buttons folder, we can add an `index.js` or `index.ts` file, and re-export all the other files in `./buttons`:

```javascript
export * from './custom-button';
```

Then we can import any of the button components as:

```javascript
import { CustomButton } from '@/components/buttons';
```

But we can take it one step further, and again re-export components from the root of `./components`. In `components/index.js`:

```javascript
export * from './test-component-one';
export * from './test-component-two';
export * from './buttons';
```

Now, any of our components can be imported directly from `./components` as:

```javascript
import { CustomButton } from '@/components';
```

This is a personal preference, and some may disagree with re-exporting everything from the root components folder, but you might find it helpful for organizing your code.

## Summary

And there you have it! That's how you can transform relative imports into root imports in Gatsby!
